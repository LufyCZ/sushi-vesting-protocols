// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class MasterVampire extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save MasterVampire entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MasterVampire entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MasterVampire", id.toString(), this);
  }

  static load(id: string): MasterVampire | null {
    return store.get("MasterVampire", id) as MasterVampire | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get poolLength(): BigInt {
    let value = this.get("poolLength");
    return value.toBigInt();
  }

  set poolLength(value: BigInt) {
    this.set("poolLength", Value.fromBigInt(value));
  }
}

export class VampirePool extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save VampirePool entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save VampirePool entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("VampirePool", id.toString(), this);
  }

  static load(id: string): VampirePool | null {
    return store.get("VampirePool", id) as VampirePool | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get victim(): Bytes {
    let value = this.get("victim");
    return value.toBytes();
  }

  set victim(value: Bytes) {
    this.set("victim", Value.fromBytes(value));
  }

  get victimPoolId(): BigInt {
    let value = this.get("victimPoolId");
    return value.toBigInt();
  }

  set victimPoolId(value: BigInt) {
    this.set("victimPoolId", Value.fromBigInt(value));
  }

  get users(): Array<string> {
    let value = this.get("users");
    return value.toStringArray();
  }

  set users(value: Array<string>) {
    this.set("users", Value.fromStringArray(value));
  }
}

export class VampireUser extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save VampireUser entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save VampireUser entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("VampireUser", id.toString(), this);
  }

  static load(id: string): VampireUser | null {
    return store.get("VampireUser", id) as VampireUser | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get vampirePool(): string {
    let value = this.get("vampirePool");
    return value.toString();
  }

  set vampirePool(value: string) {
    this.set("vampirePool", Value.fromString(value));
  }

  get balance(): BigInt {
    let value = this.get("balance");
    return value.toBigInt();
  }

  set balance(value: BigInt) {
    this.set("balance", Value.fromBigInt(value));
  }

  get actions(): Array<string> {
    let value = this.get("actions");
    return value.toStringArray();
  }

  set actions(value: Array<string>) {
    this.set("actions", Value.fromStringArray(value));
  }

  get actionsLength(): BigInt {
    let value = this.get("actionsLength");
    return value.toBigInt();
  }

  set actionsLength(value: BigInt) {
    this.set("actionsLength", Value.fromBigInt(value));
  }
}

export class Action extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Action entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Action entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Action", id.toString(), this);
  }

  static load(id: string): Action | null {
    return store.get("Action", id) as Action | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    return value.toString();
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get type(): string {
    let value = this.get("type");
    return value.toString();
  }

  set type(value: string) {
    this.set("type", Value.fromString(value));
  }

  get balanceBefore(): BigInt {
    let value = this.get("balanceBefore");
    return value.toBigInt();
  }

  set balanceBefore(value: BigInt) {
    this.set("balanceBefore", Value.fromBigInt(value));
  }

  get balanceAfter(): BigInt {
    let value = this.get("balanceAfter");
    return value.toBigInt();
  }

  set balanceAfter(value: BigInt) {
    this.set("balanceAfter", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }
}

export class Masterchef extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Masterchef entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Masterchef entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Masterchef", id.toString(), this);
  }

  static load(id: string): Masterchef | null {
    return store.get("Masterchef", id) as Masterchef | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get totalAllocPoint(): BigInt {
    let value = this.get("totalAllocPoint");
    return value.toBigInt();
  }

  set totalAllocPoint(value: BigInt) {
    this.set("totalAllocPoint", Value.fromBigInt(value));
  }

  get poolLength(): BigInt {
    let value = this.get("poolLength");
    return value.toBigInt();
  }

  set poolLength(value: BigInt) {
    this.set("poolLength", Value.fromBigInt(value));
  }
}

export class MasterchefPool extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save MasterchefPool entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MasterchefPool entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MasterchefPool", id.toString(), this);
  }

  static load(id: string): MasterchefPool | null {
    return store.get("MasterchefPool", id) as MasterchefPool | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get allocPoint(): BigInt {
    let value = this.get("allocPoint");
    return value.toBigInt();
  }

  set allocPoint(value: BigInt) {
    this.set("allocPoint", Value.fromBigInt(value));
  }

  get weight(): BigDecimal {
    let value = this.get("weight");
    return value.toBigDecimal();
  }

  set weight(value: BigDecimal) {
    this.set("weight", Value.fromBigDecimal(value));
  }

  get lastBlockUpdated(): BigInt {
    let value = this.get("lastBlockUpdated");
    return value.toBigInt();
  }

  set lastBlockUpdated(value: BigInt) {
    this.set("lastBlockUpdated", Value.fromBigInt(value));
  }

  get changes(): Array<string> {
    let value = this.get("changes");
    return value.toStringArray();
  }

  set changes(value: Array<string>) {
    this.set("changes", Value.fromStringArray(value));
  }

  get changesLength(): BigInt {
    let value = this.get("changesLength");
    return value.toBigInt();
  }

  set changesLength(value: BigInt) {
    this.set("changesLength", Value.fromBigInt(value));
  }
}

export class Change extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Change entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Change entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Change", id.toString(), this);
  }

  static load(id: string): Change | null {
    return store.get("Change", id) as Change | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get masterchefPool(): string {
    let value = this.get("masterchefPool");
    return value.toString();
  }

  set masterchefPool(value: string) {
    this.set("masterchefPool", Value.fromString(value));
  }

  get oldWeight(): BigDecimal {
    let value = this.get("oldWeight");
    return value.toBigDecimal();
  }

  set oldWeight(value: BigDecimal) {
    this.set("oldWeight", Value.fromBigDecimal(value));
  }

  get newWeight(): BigDecimal {
    let value = this.get("newWeight");
    return value.toBigDecimal();
  }

  set newWeight(value: BigDecimal) {
    this.set("newWeight", Value.fromBigDecimal(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }
}
