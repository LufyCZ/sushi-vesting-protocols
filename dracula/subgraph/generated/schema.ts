// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class MasterVampire extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save MasterVampire entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MasterVampire entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MasterVampire", id.toString(), this);
  }

  static load(id: string): MasterVampire | null {
    return store.get("MasterVampire", id) as MasterVampire | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get poolLength(): BigInt {
    let value = this.get("poolLength");
    return value.toBigInt();
  }

  set poolLength(value: BigInt) {
    this.set("poolLength", Value.fromBigInt(value));
  }
}

export class VampirePool extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save VampirePool entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save VampirePool entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("VampirePool", id.toString(), this);
  }

  static load(id: string): VampirePool | null {
    return store.get("VampirePool", id) as VampirePool | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get victim(): Bytes {
    let value = this.get("victim");
    return value.toBytes();
  }

  set victim(value: Bytes) {
    this.set("victim", Value.fromBytes(value));
  }

  get victimPoolId(): BigInt {
    let value = this.get("victimPoolId");
    return value.toBigInt();
  }

  set victimPoolId(value: BigInt) {
    this.set("victimPoolId", Value.fromBigInt(value));
  }

  get balance(): BigInt {
    let value = this.get("balance");
    return value.toBigInt();
  }

  set balance(value: BigInt) {
    this.set("balance", Value.fromBigInt(value));
  }

  get users(): Array<string> {
    let value = this.get("users");
    return value.toStringArray();
  }

  set users(value: Array<string>) {
    this.set("users", Value.fromStringArray(value));
  }
}

export class VampireUser extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save VampireUser entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save VampireUser entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("VampireUser", id.toString(), this);
  }

  static load(id: string): VampireUser | null {
    return store.get("VampireUser", id) as VampireUser | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get vampirePool(): string {
    let value = this.get("vampirePool");
    return value.toString();
  }

  set vampirePool(value: string) {
    this.set("vampirePool", Value.fromString(value));
  }

  get balance(): BigInt {
    let value = this.get("balance");
    return value.toBigInt();
  }

  set balance(value: BigInt) {
    this.set("balance", Value.fromBigInt(value));
  }
}

export class Masterchef extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Masterchef entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Masterchef entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Masterchef", id.toString(), this);
  }

  static load(id: string): Masterchef | null {
    return store.get("Masterchef", id) as Masterchef | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get totalAllocPoint(): BigInt {
    let value = this.get("totalAllocPoint");
    return value.toBigInt();
  }

  set totalAllocPoint(value: BigInt) {
    this.set("totalAllocPoint", Value.fromBigInt(value));
  }

  get poolLength(): BigInt {
    let value = this.get("poolLength");
    return value.toBigInt();
  }

  set poolLength(value: BigInt) {
    this.set("poolLength", Value.fromBigInt(value));
  }
}

export class MasterchefPool extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save MasterchefPool entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MasterchefPool entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MasterchefPool", id.toString(), this);
  }

  static load(id: string): MasterchefPool | null {
    return store.get("MasterchefPool", id) as MasterchefPool | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get masterchef(): string {
    let value = this.get("masterchef");
    return value.toString();
  }

  set masterchef(value: string) {
    this.set("masterchef", Value.fromString(value));
  }

  get allocPoint(): BigInt {
    let value = this.get("allocPoint");
    return value.toBigInt();
  }

  set allocPoint(value: BigInt) {
    this.set("allocPoint", Value.fromBigInt(value));
  }

  get balance(): BigInt {
    let value = this.get("balance");
    return value.toBigInt();
  }

  set balance(value: BigInt) {
    this.set("balance", Value.fromBigInt(value));
  }

  get lastBlockUpdated(): BigInt {
    let value = this.get("lastBlockUpdated");
    return value.toBigInt();
  }

  set lastBlockUpdated(value: BigInt) {
    this.set("lastBlockUpdated", Value.fromBigInt(value));
  }
}
